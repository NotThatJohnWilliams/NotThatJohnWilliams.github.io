formula <- as.formula(paste(resp, "~", pred, "+I(", pred, "^2)"))
lmod <- lm(formula ,data = sample)
maximum <- -lmod$coefficients[2]/(2*lmod$coefficients[3])
return(maximum)
}
maximums <- BootFun(resp = "concentration", pred = "Total_lignin", concData)
#function that returns the SE of the maximums of the fitted curve
BootFun <- function(resp, pred, data){
n <- length(data$eval(parse(resp)))
sample <- sample_n(data, size = n, replace = TRUE)
formula <- as.formula(paste(resp, "~", pred, "+I(", pred, "^2)"))
lmod <- lm(formula ,data = sample)
maximum <- -lmod$coefficients[2]/(2*lmod$coefficients[3])
return(maximum)
}
maximums <- BootFun(resp = "concentration", pred = "Total_lignin", concData)
#function that returns the SE of the maximums of the fitted curve
BootFun <- function(resp, pred, data){
n <- length(data$eval(parse(resp)))
sample <- sample_n(data, size = n, replace = TRUE)
formula <- as.formula(paste(resp, "~", pred, "+I(", pred, "^2)"))
lmod <- lm(formula ,data = sample)
maximum <- -lmod$coefficients[2]/(2*lmod$coefficients[3])
return(maximum)
}
maximums <- BootFun(resp = "concentration", pred = "Total_lignin", concData)
#function that returns the SE of the maximums of the fitted curve
BootFun <- function(resp, pred, data){
n <- length(data$eval(parse(text = resp)))
sample <- sample_n(data, size = n, replace = TRUE)
formula <- as.formula(paste(resp, "~", pred, "+I(", pred, "^2)"))
lmod <- lm(formula ,data = sample)
maximum <- -lmod$coefficients[2]/(2*lmod$coefficients[3])
return(maximum)
}
maximums <- BootFun(resp = "concentration", pred = "Total_lignin", concData)
?parse()
eval(parse(text = pred))
pred <- "Total_lignin"
eval(parse(text = pred))
data$eval(parse(text = pred))
#function that returns the SE of the maximums of the fitted curve
BootFun <- function(resp, pred, data){
n <- length(data$parse(text = resp))
sample <- sample_n(data, size = n, replace = TRUE)
formula <- as.formula(paste(resp, "~", pred, "+I(", pred, "^2)"))
lmod <- lm(formula ,data = sample)
maximum <- -lmod$coefficients[2]/(2*lmod$coefficients[3])
return(maximum)
}
maximums <- BootFun(resp = "concentration", pred = "Total_lignin", concData)
parse(text = pred)
as.name(pred)
#function that returns the SE of the maximums of the fitted curve
BootFun <- function(resp, pred, data){
n <- length(data$(asname(pred)))
#function that returns the SE of the maximums of the fitted curve
BootFun <- function(resp, pred, data){
sample <- sample_n(data, size = n, replace = TRUE)
formula <- as.formula(paste(resp, "~", pred, "+I(", pred, "^2)"))
lmod <- lm(formula ,data = sample)
maximum <- -lmod$coefficients[2]/(2*lmod$coefficients[3])
return(maximum)
}
maximums <- BootFun(resp = "concentration", pred = "Total_lignin", concData)
#function that returns the SE of the maximums of the fitted curve
BootFun <- function(resp, pred, data){
sample <- sample_n(data, size = n, replace = TRUE)
formula <- as.formula(paste(resp, "~", pred, "+I(", pred, "^2)"))
lmod <- lm(formula ,data = sample)
maximum <- -lmod$coefficients[2]/(2*lmod$coefficients[3])
return(maximum)
}
maximums <- BootFun(resp = "concentration", pred = "Total_lignin", concData)
#function that returns the SE of the maximums of the fitted curve
BootFun <- function(resp, pred, data){
sample <- sample_n(data, size = n, replace = TRUE)
formula <- as.formula(paste(resp, "~", pred, "+I(", pred, "^2)"))
lmod <- lm(formula, data = sample)
maximum <- -lmod$coefficients[2]/(2*lmod$coefficients[3])
return(maximum)
}
seBootFun <- function(B, resp, pred, data){
maximums <- replicate(B, BootFun(resp, pred, data = concData))
estimated_SE <- sd(maximums)/sqrt(n)
return(estimated_SE)
}
std_errors <- BootFun(resp = "concentration", pred = "Total_lignin", concData)
#function that returns the SE of the maximums of the fitted curve
BootFun <- function(resp, pred, data){
sample <- sample_n(data, size = n, replace = TRUE)
formula <- as.formula(paste(resp, "~", pred, "+I(", pred, "^2)"))
lmod <- lm(formula, data = sample)
maximum <- -lmod$coefficients[2]/(2*lmod$coefficients[3])
return(maximum)
}
seBootFun <- function(B, resp, pred, data){
maximums <- replicate(B, BootFun(resp, pred, data = concData))
estimated_SE <- sd(maximums)/sqrt(n)
return(estimated_SE)
}
responses <- c("Total_lignin", "Glucose", "Xylose", "Arabinose")
std_errors <- BootFun(resp = "concentration", pred = responses, concData)
#function that returns the SE of the maximums of the fitted curve
BootFun <- function(resp, pred, data){
sample <- sample_n(data, size = n, replace = TRUE)
formula <- as.formula(paste(resp, "~", pred, "+I(", pred, "^2)"))
lmod <- lm(formula, data = sample)
maximum <- -lmod$coefficients[2]/(2*lmod$coefficients[3])
return(maximum)
}
seBootFun <- function(B, resp, pred, data){
maximums <- replicate(B, BootFun(resp, pred, data = concData))
estimated_SE <- sd(maximums)/sqrt(n)
return(estimated_SE)
}
responses <- c("Total_lignin", "Glucose", "Xylose", "Arabinose")
std_errors <- BootFun(resp = "concentration", pred = responses, concData)
#function that returns the SE of the maximums of the fitted curve
BootFun <- function(resp, pred, data){
sample <- sample_n(data, size = n, replace = TRUE)
formula <- as.formula(paste(resp, "~", pred, "+I(", pred, "^2)"))
lmod <- lm(formula, data = sample)
maximum <- -lmod$coefficients[2]/(2*lmod$coefficients[3])
return(maximum)
}
seBootFun <- function(B, resp, pred, data){
maximums <- replicate(B, BootFun(resp, pred, data = concData))
estimated_SE <- sd(maximums)/sqrt(n)
return(estimated_SE)
}
responses <- c("Total_lignin", "Glucose", "Xylose", "Arabinose")
std_errors <- BootFun(resp = "concentration", pred = responses, concData)
#function that returns the SE of the maximums of the fitted curve
BootFun <- function(resp, pred, data){
sample <- sample_n(data, size = n, replace = TRUE)
formula <- as.formula(paste(resp, "~", pred, "+I(", pred, "^2)"))
lmod <- lm(formula, data = sample)
maximum <- -lmod$coefficients[2]/(2*lmod$coefficients[3])
return(maximum)
}
seBootFun <- function(B, resp, pred, data){
maximums <- replicate(B, BootFun(resp, pred, data = concData))
estimated_SE <- sd(maximums)/sqrt(n)
return(estimated_SE)
}
responses <- c("Total_lignin", "Glucose", "Xylose", "Arabinose")
std_errors <- BootFun(resp = "concentration", pred = responses, concData)
?lapply()
#function that returns the SE of the maximums of the fitted curve
BootFun <- function(resp, pred, data){
sample <- sample_n(data, size = n, replace = TRUE)
formula <- as.formula(paste(resp, "~", pred, "+I(", pred, "^2)"))
lmod <- lm(formula, data = sample)
maximum <- -lmod$coefficients[2]/(2*lmod$coefficients[3])
return(maximum)
}
seBootFun <- function(B, resp, pred, data){
maximums <- replicate(B, BootFun(resp, pred, data = concData))
estimated_SE <- sd(maximums)/sqrt(n)
return(estimated_SE)
}
responses <- c("Total_lignin", "Glucose", "Xylose", "Arabinose")
std_errors <- lappy(responses, BootFun, resp = "concentration", pred = responses, concData)
#function that returns the SE of the maximums of the fitted curve
BootFun <- function(resp, pred, data){
sample <- sample_n(data, size = n, replace = TRUE)
formula <- as.formula(paste(resp, "~", pred, "+I(", pred, "^2)"))
lmod <- lm(formula, data = sample)
maximum <- -lmod$coefficients[2]/(2*lmod$coefficients[3])
return(maximum)
}
seBootFun <- function(B, resp, pred, data){
maximums <- replicate(B, BootFun(resp, pred, data = concData))
estimated_SE <- sd(maximums)/sqrt(n)
return(estimated_SE)
}
responses <- c("Total_lignin", "Glucose", "Xylose", "Arabinose")
std_errors <- lappy(responses, FUN = seBootFun, B = B,
resp = "concentration", data = concData)
#function that returns the SE of the maximums of the fitted curve
BootFun <- function(resp, pred, data){
sample <- sample_n(data, size = n, replace = TRUE)
formula <- as.formula(paste(resp, "~", pred, "+I(", pred, "^2)"))
lmod <- lm(formula, data = sample)
maximum <- -lmod$coefficients[2]/(2*lmod$coefficients[3])
return(maximum)
}
seBootFun <- function(B, resp, pred, data){
maximums <- replicate(B, BootFun(resp, pred, data = concData))
estimated_SE <- sd(maximums)/sqrt(n)
return(estimated_SE)
}
predictor <- c("Total_lignin", "Glucose", "Xylose", "Arabinose")
std_errors <- lapply(predictor, FUN = seBootFun, B = B,
resp = "concentration", data = concData)
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
library(tidyverse)
setwd("C:/ST558/")
concData <- read_csv("./HW6/concentration.csv")
B <- 5000
n <- length(concData$concentration)    #number of observations in concData
#function that returns the maximum of the fitted curve
bootFun <- function(n, data){
sample <- sample_n(data, size = n, replace = TRUE)
lmod <- lm(Total_lignin ~ concentration + I(concentration^2),
data = sample)
maximum <- -lmod$coefficients[2]/(2*lmod$coefficients[3])
return(maximum)
}
maximums_forloop <- rep(0, times = B)    #initialize vector to store maximums
#run bootstrap B times
for (i in 1:B){
maximums_forloop[i] <- bootFun(n, data = concData)
}
estimated_maximum <- mean(maximums_forloop)
estimated_SE <- sd(maximums_forloop)/sqrt(n)
#run bootstrap B times
maximums_replicate <- replicate(B, bootFun(n, data = concData))
#calculate maximum and its standard error
estimated_maximum <- mean(maximums_replicate)
estimated_SE <- sd(maximums_replicate)/sqrt(n)
B <- 5000
n <- length(concData$concentration)    #number of observations in concData
#function that returns the maximum of the fitted curve
bootFun <- function(resp, pred, data){
sample <- sample_n(data, size = n, replace = TRUE)
formula <- as.formula(paste(resp, "~", pred, "+I(", pred, "^2)"))
lmod <- lm(formula, data = sample)
maximum <- -lmod$coefficients[2]/(2*lmod$coefficients[3])
return(maximum)
}
maximums_forloop <- rep(0, times = B)    #initialize vector to store maximums
#run bootstrap B times
for (i in 1:B){
maximums_forloop[i] <- bootFun(resp = "Total_lignin", pred = "concentration",
data = concData)
}
estimated_maximum <- mean(maximums_forloop)
estimated_SE <- sd(maximums_forloop)/sqrt(n)
#function that returns the SE of the estimated maximums of the fitted curve
seBootFun <- function(B, resp, pred, data){
maximums <- replicate(B, bootFun(resp, pred, data = concData))
estimated_SE <- sd(maximums)/sqrt(n)
return(estimated_SE)
}
predictor <- c("Total_lignin", "Glucose", "Xylose", "Arabinose")
std_errors <- lapply(predictor, FUN = seBootFun, B = B,
resp = "concentration", data = concData)
#function that returns the SE of the estimated maximums of the fitted curve
seBootFun <- function(B, resp, pred, data){
maximums <- replicate(B, bootFun(resp, pred, data = concData))
estimated_SE <- sd(maximums)/sqrt(n)
return(estimated_SE)
}
responses <- c("Total_lignin", "Glucose", "Xylose", "Arabinose")
std_errors <- lapply(responses, FUN = seBootFun, B = B,
pred = "concentration", data = concData)
library(parallel)
cluster <- makeCluster(4)
cluster
library(parallel)
#set up cores
cluster <- makeCluster(4)
#send packages and functions to cores (in Windows)
clusterExport(cluster, list("bootFun", "seBootFun"))
clusterEvalQ(cluster, library(tidyverse))
library(parallel)
#set up cores
cluster <- makeCluster(4)
#send packages and functions to cores (in Windows)
clusterExport(cluster, list("bootFun", "seBootFun"))
clusterEvalQ(cluster, library(tidyverse))
std_errors <- parLapply(cluster, fun = seBootFun, B = B,
pred = "concentration", data = concData)
parLapply()
?parLapply()
library(parallel)
#set up cores
cluster <- makeCluster(4)
#send packages and functions to cores (in Windows)
clusterExport(cluster, list("bootFun", "seBootFun"))
clusterEvalQ(cluster, library(tidyverse))
std_errors <- parLapply(cluster, X = responses, fun = seBootFun, B = B,
pred = "concentration", data = concData)
library(parallel)
#set up cores
cluster <- makeCluster(4)
#send packages and functions to cores (in Windows)
clusterExport(cluster, list("bootFun", "seBootFun", "concData"))
clusterEvalQ(cluster, library(tidyverse))
std_errors <- parLapply(cluster, X = responses, fun = seBootFun, B = B,
pred = "concentration", data = concData)
library(parallel)
#set up cores
cluster <- makeCluster(4)
#send packages and functions to cores (in Windows)
clusterExport(cluster, list("bootFun", "seBootFun", "concData"))
clusterEvalQ(cluster, library(tidyverse))
std_errors <- parLapply(cluster, X = responses, FUN = seBootFun, B = B,
pred = "concentration", data = concData)
library(parallel)
#set up cores
cluster <- makeCluster(4)
#send packages and functions to cores (in Windows)
clusterExport(cluster, list("bootFun", "seBootFun", "concData"))
clusterEvalQ(cluster, library(tidyverse))
std_errors <- parLapply(cluster, X = responses, fun = seBootFun, B = B,
pred = "concentration", data = concData)
library(parallel)
#set up cores
cluster <- makeCluster(4)
#send packages and functions to cores (in Windows)
clusterExport(cluster, list("bootFun", "seBootFun", "concData", "responses"))
clusterEvalQ(cluster, library(tidyverse))
std_errors <- parLapply(cluster, X = responses, fun = seBootFun, B = B,
pred = "concentration", data = concData)
library(parallel)
#set up cores
cluster <- makeCluster(4)
#send packages and functions to cores (in Windows)
clusterExport(cluster, list("bootFun", "seBootFun", "concData"))
clusterEvalQ(cluster, library(tidyverse))
std_errors <- parLapply(cluster, X = responses, fun = seBootFun, B = B,
pred = "concentration", data = concData)
responses
?responses
B
?B
pred
cluster
?cluster
?cluster()
?B()
?responses()
library(parallel)
#set up cores
cluster <- makeCluster(4)
#send packages and functions to cores (in Windows)
clusterExport(cluster, list("bootFun", "seBootFun", "concData"))
clusterEvalQ(cluster, library(tidyverse))
std_errors <- parLapply(cluster,  = responses, fun = seBootFun, B = B,
library(parallel)
#set up cores
cluster <- makeCluster(4)
#send packages and functions to cores (in Windows)
clusterExport(cluster, list("bootFun", "seBootFun", "concData"))
clusterEvalQ(cluster, library(tidyverse))
std_errors <- parLapply(cluster, x = responses, fun = seBootFun, B = B,
pred = "concentration", data = concData)
library(parallel)
#set up cores
cluster <- makeCluster(4)
#send packages and functions to cores (in Windows)
clusterExport(cluster, list("bootFun", "seBootFun", "concData"))
clusterEvalQ(cluster, library(tidyverse))
std_errors <- parLapply(cluster, X = responses, fun = seBootFun, B = B,
pred = "concentration", data = concData)
library(parallel)
#set up cores
cluster <- makeCluster(4)
#send packages and functions to cores (in Windows)
clusterExport(cluster, list("bootFun", "seBootFun", "concData"))
clusterEvalQ(cluster, library(tidyverse))
clusterEvalQ(cluster, library(base))
std_errors <- parLapply(cluster, X = responses, fun = seBootFun, B = B,
pred = "concentration", data = concData)
library(parallel)
#set up cores
cluster <- makeCluster(4)
#send packages and functions to cores (in Windows)
clusterExport(cluster, list("bootFun", "seBootFun", "concData"))
clusterEvalQ(cluster, library(tidyverse))
clusterEvalQ(cluster, library(base))
clusterEvalQ(cluster, library(stats))
std_errors <- parLapply(cluster, X = responses, fun = seBootFun, B = B,
pred = "concentration", data = concData)
library(parallel)
#set up cores
cluster <- makeCluster(4)
#send packages and functions to cores (in Windows)
clusterExport(cluster, list("bootFun", "seBootFun", "concData"))
clusterEvalQ(cluster, library(tidyverse))
#clusterEvalQ(cluster, library(base))
#clusterEvalQ(cluster, library(stats))
std_errors <- parLapply(cluster, X = responses, fun = seBootFun, B = B,
pred = "concentration", data = concData)
parLapply(cluster, X = responses, fun = seBootFun, B = B,
+                     pred = "concentration", data = concData)
parLapply(cluster, X = responses, fun = seBootFun, B = B, pred = "concentration", data = concData)
?checkForRemoteErrors()
library(parallel)
#set up cores
cluster <- makeCluster(4)
#send packages and functions to cores (in Windows)
clusterExport(cluster, list("bootFun", "seBootFun", "concData", "B"))
clusterEvalQ(cluster, library(tidyverse))
#clusterEvalQ(cluster, library(base))
#clusterEvalQ(cluster, library(stats))
std_errors <- parLapply(cluster, X = responses, fun = seBootFun, B = B,
pred = "concentration", data = concData)
library(parallel)
#set up cores
cluster <- makeCluster(4)
#send packages and functions to cores (in Windows)
clusterExport(cluster, list("bootFun", "seBootFun", "concData", "B", "n"))
clusterEvalQ(cluster, library(tidyverse))
#clusterEvalQ(cluster, library(base))
#clusterEvalQ(cluster, library(stats))
std_errors <- parLapply(cluster, X = responses, fun = seBootFun, B = B,
pred = "concentration", data = concData)
library(parallel)
#set up cores
cluster <- makeCluster(4)
#send packages and functions to cores (in Windows)
clusterExport(cluster, list("bootFun", "seBootFun", "concData", "B", "n"))
clusterEvalQ(cluster, library(tidyverse))
#clusterEvalQ(cluster, library(base))
#clusterEvalQ(cluster, library(stats))
std_errors <- parLapply(cluster, X = responses, fun = seBootFun, B = B,
pred = "concentration", data = concData)
library(parallel)
#set up cores
cluster <- makeCluster(4)
#send packages and functions to cores (in Windows)
clusterExport(cluster, list("bootFun", "seBootFun", "concData", "n"))
clusterEvalQ(cluster, library(tidyverse))
#clusterEvalQ(cluster, library(base))
#clusterEvalQ(cluster, library(stats))
std_errors <- parLapply(cluster, X = responses, fun = seBootFun, B = B,
pred = "concentration", data = concData)
library(parallel)
#set up cores
cluster <- makeCluster(4)
#send packages and functions to cores (in Windows)
clusterExport(cluster, list("bootFun", "seBootFun", "concData", "B", "n"))
clusterEvalQ(cluster, library(tidyverse))
#clusterEvalQ(cluster, library(base))
#clusterEvalQ(cluster, library(stats))
std_errors <- parLapply(cluster, X = responses, fun = seBootFun, B = B,
pred = "concentration", data = concData)
lmod_1 <- lm(Total_lignin ~ concentration + I(concentration^2),
data = concData)
lmod_2 <- lm(Glucose ~ concentration + I(concentration^2),
data = concData)
lmod_3 <- lm(Xylose ~ concentration + I(concentration^2),
data = concData)
lmod_4 <- lm(Arabinose ~ concentration + I(concentration^2),
data = concData)
maxs <- rep(0, 4)
maxs[1] <- -lmod_1$coefficients[2]/(2*lmod_1$coefficients[3])
maxs[2] <- -lmod_2$coefficients[2]/(2*lmod_2$coefficients[3])
maxs[3] <- -lmod_3$coefficients[2]/(2*lmod_3$coefficients[3])
maxs[4] <- -lmod_4$coefficients[2]/(2*lmod_4$coefficients[3])
lmod_1 <- lm(Total_lignin ~ concentration + I(concentration^2),
data = concData)
lmod_2 <- lm(Glucose ~ concentration + I(concentration^2),
data = concData)
lmod_3 <- lm(Xylose ~ concentration + I(concentration^2),
data = concData)
lmod_4 <- lm(Arabinose ~ concentration + I(concentration^2),
data = concData)
maxs <- rep(0, 4)
maxs[1] <- -lmod_1$coefficients[2]/(2*lmod_1$coefficients[3])
maxs[2] <- -lmod_2$coefficients[2]/(2*lmod_2$coefficients[3])
maxs[3] <- -lmod_3$coefficients[2]/(2*lmod_3$coefficients[3])
maxs[4] <- -lmod_4$coefficients[2]/(2*lmod_4$coefficients[3])
lmod_1 <- lm(Total_lignin ~ concentration + I(concentration^2),
data = concData)
lmod_2 <- lm(Glucose ~ concentration + I(concentration^2),
data = concData)
lmod_3 <- lm(Xylose ~ concentration + I(concentration^2),
data = concData)
lmod_4 <- lm(Arabinose ~ concentration + I(concentration^2),
data = concData)
maxs <- rep(0, 4)
maxs[1] <- -lmod_1$coefficients[2]/(2*lmod_1$coefficients[3])
maxs[2] <- -lmod_2$coefficients[2]/(2*lmod_2$coefficients[3])
maxs[3] <- -lmod_3$coefficients[2]/(2*lmod_3$coefficients[3])
maxs[4] <- -lmod_4$coefficients[2]/(2*lmod_4$coefficients[3])
#function that returns the SE of the estimated maximums of the fitted curve
seBootFun <- function(B, resp, pred, data){
maximums <- replicate(B, bootFun(resp, pred, data = concData))
estimated_SE <- sd(maximums)/sqrt(n)
return(estimated_SE)
}
responses <- c("Total_lignin", "Glucose", "Xylose", "Arabinose")
std_errors <- lapply(responses, FUN = seBootFun, B = B,
pred = "concentration", data = concData)
?round()
library(parallel)
#set up cores
cluster <- makeCluster(4)
#send packages and functions to cores (in Windows)
clusterExport(cluster, list("bootFun", "seBootFun", "concData", "B", "n"))
clusterEvalQ(cluster, library(tidyverse))
#clusterEvalQ(cluster, library(base))
#clusterEvalQ(cluster, library(stats))
std_errors <- parLapply(cluster, X = responses, fun = seBootFun, B = B,
pred = "concentration", data = concData)
rmarkdown::render("_Rmd/2021-10-05-API-Vignette.Rmd",
output_format = "github_document",
output_dir = "_posts",
output_file = "2021-10-05-API-Vignette.md")
rmarkdown::render("_Rmd/2021-10-05-API-Vignette.Rmd",
output_format = "github_document",
output_dir = "_posts",
output_file = "2021-10-05-API-Vignette.md")
rmarkdown::render("_Rmd/2021-10-05-API-Vignette.Rmd",
output_format = "github_document",
output_dir = "_posts",
output_file = "2021-10-05-API-Vignette.md")
